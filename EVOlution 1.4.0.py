#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#  â–ˆâ–€â€ƒâ–ˆ â–ˆâ€ƒâ–€â–„â–€â€ƒ â€ƒâ–ˆâ–€â–„â–€â–ˆâ€ƒâ–ˆâ–€â–ˆâ€ƒâ–ˆâ–€â–„â€ƒâ–ˆ â–ˆâ€ƒâ–ˆ  â€ƒâ–ˆâ–€â–€â€ƒâ–ˆâ–€ Chanel: https://shx_modules
#  â–„â–ˆâ€ƒâ–ˆâ–€â–ˆâ€ƒâ–ˆ â–ˆâ€ƒ â€ƒâ–ˆ â–€ â–ˆâ€ƒâ–ˆâ–„â–ˆâ€ƒâ–ˆâ–„â–€â€ƒâ–ˆâ–„â–ˆâ€ƒâ–ˆâ–„â–„â€ƒâ–ˆâ–ˆâ–„â€ƒâ–„â–ˆ Not Licensed
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
#  â–ˆâ–€â–€â€ƒâ–€â–„â–€â€ƒâ–ˆ  â€ƒâ–ˆ â–ˆâ€ƒâ–ˆâ–€â€ƒâ–ˆâ€ƒâ–ˆ â–ˆâ€ƒâ–ˆâ–€â–€â€ƒ â€ƒâ–ˆâ–€â–„â–€â–ˆâ€ƒâ–ˆâ–€â–ˆâ€ƒâ–ˆâ–€â–„â€ƒâ–ˆ â–ˆâ€ƒâ–ˆ  â€ƒâ–ˆâ–€â–€â€ƒâ–ˆâ–€
#  â–ˆâ–ˆâ–„â€ƒâ–ˆ â–ˆâ€ƒâ–ˆâ–„â–„â€ƒâ–ˆâ–„â–ˆâ€ƒâ–„â–ˆâ€ƒâ–ˆâ€ƒâ–€â–„â–€â€ƒâ–ˆâ–ˆâ–„â€ƒ â€ƒâ–ˆ â–€ â–ˆâ€ƒâ–ˆâ–„â–ˆâ€ƒâ–ˆâ–„â–€â€ƒâ–ˆâ–„â–ˆâ€ƒâ–ˆâ–„â–„â€ƒâ–ˆâ–ˆâ–„â€ƒâ–„â–ˆ
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
# Idea: sqlmerr
# meta developer: @shx_modules
# Thanks: 
#â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”


import asyncio
import re
from telethon.tl.types import Message, ChatAdminRights
from telethon import functions
import logging
import argparse
from asyncio import sleep
from .. import loader, utils
from ..inline.types import InlineCall

logger = logging.getLogger(__name__)

@loader.tds
class EVOlution(loader.Module):
    """ĞœĞ¾Ğ´ÑƒĞ»ÑŒ Ğ´Ğ»Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ Ğ°ĞºĞºĞ°ÑƒĞ½Ñ‚Ğ¾Ğ¼ mine_evo_bot.t.me\nDeveloper: @Shx_modules\n\nĞ Ğ±Ğ°Ğ³Ğ°Ñ…/Ğ¿Ñ€ĞµĞ´Ğ»Ğ¾Ğ¶ĞµĞ½Ğ¸ÑÑ…: @Shxdowrate"""
    strings = {
        "name" : "EVOlution 1.4.0",
        "cfg_waiting_time" : "Ğ’Ñ€ĞµĞ¼Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ¾Ñ‚ Ğ±Ğ¾Ñ‚Ğ°\nĞ”Ğ»Ñ .evo",
        'delay_craft' : 'Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¾Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ° Ğ½Ğ° ĞºÑ€Ğ°Ñ„Ñ‚ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ°\nĞ”Ğ»Ñ .craft',
        'autoattack' : 'ĞĞ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ°Ñ Ğ°Ñ‚Ğ°ĞºĞ° Ğ±Ğ¾ÑÑĞ¾Ğ²\nĞ£Ñ‡Ñ‚Ğ¸Ñ‚Ğµ, Ğ²Ğ°Ğ¼ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ²Ñ‹Ğ±Ñ€Ğ°Ñ‚ÑŒ Ğ±Ğ¾ÑÑĞ°, Ğ° Ğ±Ğ¾Ñ‚ Ğ¿Ñ€Ğ¾Ğ´Ğ¾Ğ»Ğ¶Ğ¸Ñ‚ ĞµĞ³Ğ¾ Ğ°Ñ‚Ğ°ĞºĞ¾Ğ²Ğ°Ñ‚ÑŒ',
        'delay_boss' : 'Ğ—Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ° Ğ¼ĞµĞ¶Ğ´Ñƒ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²ĞºĞ¾Ğ¹ Ğ°Ñ‚Ğ°ĞºĞ¸',
        'result_attack' : 'ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ»Ğ¸ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚ Ğ±Ğ¾Ñ Ğº Ğ²Ğ°Ğ¼ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ñ‹Ğµ?\nĞ Ğ°Ğ±Ğ¾Ñ‚Ğ°ĞµÑ‚ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ñ€Ğ¸ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ½Ğ¾Ğ¼ autoattack',
        'gif_inline' : 'Ğ“Ğ¸Ñ„ Ğ² inline Ñ‚Ğ¾Ğ¿Ğµ Ğ¸ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»Ğµ.',
        'petroleum' : 'Ğ”Ğ¾Ğ±Ñ‹Ğ²Ğ°Ñ‚ÑŒ Ğ½ĞµÑ„Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸?\nĞ’ĞºĞ»ÑÑ‡Ğ°Ğ¹Ñ‚Ğµ Ñ‡ĞµÑ€ĞµĞ· .petroleum!',
        'thank_you': "ĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ÑÑ‚ÑŒ Ğ»Ğ¸ Ğ¿Ñ€Ğ¸ ÑĞ»ĞµĞ´ÑƒÑÑ‰ĞµĞ¼ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ Ğ±Ğ»Ğ°Ğ³Ğ¾Ğ´Ğ°Ñ€ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾Ğµ Ğ¿Ğ¸ÑÑŒĞ¼Ğ¾ Ğ² Ğ»Ñ?",
    }
    
    


    async def client_ready(self):
        self._backup_channel, _ = await utils.asset_channel(
            self._client,
            "EVOQasst",
            "Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ° Ğ´Ğ»Ñ Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‹ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ EVO Ğ¾Ñ‚ @Shx_modules\nĞĞµ Ğ´Ğ¾Ğ±Ğ°Ğ²Ğ»ÑĞ¹Ñ‚Ğµ ÑÑĞ´Ğ° Ğ´Ñ€ÑƒĞ³Ğ¸Ñ… Ğ»ÑĞ´ĞµĞ¹ Ğ¸Ğ»Ğ¸ Ğ±Ğ¾Ñ‚Ğ¾Ğ²!",
            silent=True,
            archive=True,
            _folder="hikka",
        )

        await self.client(functions.channels.InviteToChannelRequest(self._backup_channel, ['@mine_evo_bot']))
        await self.client(functions.channels.EditAdminRequest(
                channel=self._backup_channel,
                user_id="@mine_evo_bot",
                admin_rights=ChatAdminRights(ban_users=True, post_messages=True, edit_messages=True),
                rank="EVO",
            )
        )
        thank = self.config['thank_you']
        if thank == True:
            await self.client.send_message('me','<emoji document_id=5206399660184313498>â¤ï¸</emoji> <b>Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ Ğ·Ğ° ÑƒÑÑ‚Ğ°Ğ½Ğ¾Ğ²ĞºÑƒ Ğ¼Ğ¾Ğ´ÑƒĞ»Ñ EVOlution!</b>\n\nĞĞ° ÑĞ°Ğ¼Ğ¾Ğ¼ Ğ´ĞµĞ»Ğµ, ÑÑ‚Ğ¾ Ğ¸ÑĞºÑ€ĞµĞ½Ğ½ĞµĞµ "Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾"! Ğ¯ Ğ¸ Ğ² Ğ¿Ñ€Ğ°Ğ²Ğ´Ñƒ Ğ¾Ñ‡ĞµĞ½ÑŒ Ñ€Ğ°Ğ´, Ñ‡Ñ‚Ğ¾ Ğ¼Ğ¾Ğµ Ñ‚Ğ²Ğ¾Ñ€ĞµĞ½Ğ¸Ğµ Ğ¿Ğ¾Ğ¿Ğ°Ğ»Ğ¾ Ğº Ğ²Ğ°Ğ¼ Ğ² ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹.\n\nĞ­Ñ‚Ğ¾ ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğµ Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ğ»Ğ¾ÑÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¾Ğ´Ğ¸Ğ½ Ñ€Ğ°Ğ· Ğ¸ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğº Ğ²Ğ°Ğ¼ Ğ² Ğ¸Ğ·Ğ±Ñ€Ğ°Ğ½Ğ½Ğ¾Ğµ, Ğ¿Ğ¾ÑÑ‚Ğ¾Ğ¼Ñƒ Ğ²Ğ°Ğ¼ Ğ½Ğµ ÑÑ‚Ğ¾Ğ¸Ñ‚ Ğ¿ĞµÑ€ĞµĞ¶Ğ¸Ğ²Ğ°Ñ‚ÑŒ :D\n\nĞ•ÑĞ»Ğ¸ Ğ²Ğ°Ñ Ğ·Ğ°Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑÑƒÑÑ‚ Ğ¼Ğ¾Ğ¸ Ğ¼Ğ¾Ğ´ÑƒĞ»Ğ¸, Ğ¶Ğ´Ñƒ Ğ²Ğ°Ñ Ğ² shx_modules.t.me\nĞ¡Ğ±Ğ¾Ñ€Ğ½Ğ¸Ğº Ğ²ÑĞµÑ…(Ğ¿Ğ¾Ñ‡Ñ‚Ğ¸) Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¹ Ğ´Ğ»Ñ Ñ…Ğ¸ĞºĞºĞ¸: ubhikka_modules.t.me')
            await self.client.send_message('me', '<emoji document_id=5255900725933779026>ğŸ” </emoji><emoji document_id=5255854937287435776>ğŸ” </emoji><emoji document_id=5256005879618086735>ğŸ” </emoji><emoji document_id=5255854937287435776>ğŸ” </emoji><emoji document_id=5255737126334506261>ğŸ” </emoji><emoji document_id=5255838994368834442>ğŸ” </emoji><emoji document_id=5256057178707469647>ğŸ” </emoji><emoji document_id=5255854937287435776>ğŸ” </emoji><emoji document_id=6032769737509833594>ğŸ“›</emoji><emoji document_id=5258045984788717832>ğŸ” </emoji><emoji document_id=5255972975873632543>ğŸ” </emoji><emoji document_id=5255973950831208848>ğŸ” </emoji><emoji document_id=5255935626838025893>ğŸ” </emoji>')


    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "waiting_time", 1.0,
                lambda: self.strings("cfg_waiting_time"),
                validator=loader.validators.Float()
            ),
            loader.ConfigValue(
                "delay_craft", 2.0,
                lambda: self.strings("delay_craft"),
                validator=loader.validators.Float()
            ),
            loader.ConfigValue(
                "autoattack", False,
                lambda: self.strings("autoattack"),
                validator=loader.validators.Boolean()
            ),
            loader.ConfigValue(
                "delay_boss", 1.0,
                lambda: self.strings("delay_boss"),
                validator=loader.validators.Float()
            ),
            loader.ConfigValue(
                "result_attack", True,
                lambda: self.strings("result_attack"),
                validator=loader.validators.Boolean()
            ),           
            loader.ConfigValue(
                "gif_inline", 'https://x0.at/n5Gn.mp4',
                lambda: self.strings("gif_inline"),
                validator=loader.validators.String()
            ),
            loader.ConfigValue(
                "petroleum", False,
                lambda: self.strings("petroleum"),
                validator=loader.validators.Boolean()
            ),
            loader.ConfigValue(
                "thank_you", True,
                lambda: self.strings("thank_you"),
                validator=loader.validators.Boolean()
            ),
        )

    @loader.watcher()
    async def watcher2(self, message):
        autoattack = self.config['autoattack']
        delay_boss = self.config['delay_boss']
        result_attack = self.config['result_attack']
        petroleum = self.config['petroleum']
        

        if autoattack == True:
            if message.chat_id == 5522271758 and "ĞÑ‚Ğº)" in message.raw_text:
                await asyncio.sleep(delay_boss)
                await self.client.send_message('@mine_evo_bot', 'ĞÑ‚Ğº')    
            elif message.chat_id == 5522271758 and 'ğŸ”¶ Ğ¢Ñ‹ Ğ²Ñ‹Ğ±Ñ€Ğ°Ğ» Ğ±Ğ¾ÑÑĞ°:' in message.raw_text:
                await asyncio.sleep(delay_boss)
                await self.client.send_message('@mine_evo_bot', 'ĞÑ‚Ğº')    
            if result_attack == True:
                if message.chat_id == 5522271758 and "Ğ¢Ğ²Ğ¾Ñ Ğ½Ğ°Ğ³Ñ€Ğ°Ğ´Ğ°:" in message.raw_text: 
                    await self.client.send_message('me', message.raw_text)
        if petroleum == True:
            if message.chat_id == 5522271758 and "ĞĞµÑ„Ñ‚Ğ¸ Ğ² Ğ¼ĞµÑÑ‚Ğ¾Ñ€Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğ¸:" in message.raw_text:
                await asyncio.sleep(2)
                await self.client.send_message('@mine_evo_bot', 'ĞšĞ°Ñ‡Ğ°Ñ‚ÑŒ')
            if message.chat_id == 5522271758 and "ĞºĞ¾Ğ½Ñ‡Ğ¸Ğ»Ğ°ÑÑŒ Ğ½ĞµÑ„Ñ‚ÑŒ!" in message.raw_text:
                await asyncio.sleep(3600)
                await self.client.send_message('@mine_evo_bot', "ĞšĞ°Ñ‡Ğ°Ñ‚ÑŒ")
                
    @loader.command()
    async def evo(self, message: Message):
        """[ Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ ] - Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ\nĞŸÑ€Ğ¸Ğ¼ĞµÑ€: .evo Ğ¿Ñ€Ğ¾Ñ„"""
        args = utils.get_args_raw(message)
        waiting_time = self.config["waiting_time"]
        error_not_args = "<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ° </b>\nĞ’Ñ‹ Ğ½Ğµ Ğ²Ğ²ĞµĞ»Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ!"
        error_not_response = f"<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ°</b>\nĞĞ° Ğ²Ğ°Ñˆ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğµ Ğ±Ñ‹Ğ» Ğ¿Ğ¾Ğ»ÑƒÑ‡ĞµĞ½ Ğ¾Ñ‚Ğ²ĞµÑ‚ Ğ² Ñ‚ĞµÑ‡ĞµĞ½Ğ¸Ğµ {waiting_time} ÑĞµĞºÑƒĞ½Ğ´(-Ñ‹)\n<b>Ğ’Ğ°Ñˆ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ:</b> {args} \n\n<emoji document_id=5787544344906959608>â„¹ï¸</emoji> <b>Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¾Ğ±Ğ»ĞµĞ¼Ñ‹:</b>"
        ore = "<b>Ğ¦ĞµĞ½Ñ‹ Ğ½Ğ° Ñ€ÑƒĞ´Ñ‹:</b>\n> https://teletype.in/@mine_evo/ores_prices_1"
        err_d1 = "\n> Ğ’Ñ‹ Ğ²Ğ²ĞµĞ»Ğ¸ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ, ĞºĞ¾Ñ‚Ğ¾Ñ€Ğ¾Ğ³Ğ¾ Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚."
        err_d2 = "\n> Ğ£ MineEVO Ğ²Ñ‹ÑĞ¾ĞºĞ¸Ğ¹ Ğ¿Ğ¸Ğ½Ğ³."

        if args == '':
            await utils.answer(message, error_not_args)
        elif args in ["Ğ¦ĞµĞ½Ñ‹","Ñ†ĞµĞ½Ñ‹","Ñ€Ñ‹Ğ½Ğ¾Ğº","Ğ Ñ‹Ğ½Ğ¾Ğº"]:
            await utils.answer(message, ore)
        else:
            await utils.answer(message, '<b>[ evo ]</b> Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ...')
            async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'{args}')
                try:
                    response = await asyncio.wait_for(conv.get_response(), timeout=waiting_time)
                except asyncio.TimeoutError:
                    await utils.answer(message, error_not_response + err_d1 + err_d2)
                    return
            links_regex = re.compile(r'.(https?://\S+).')
            response.text = links_regex.sub('', response.text)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response.text):
                response.text = '\n'.join(response.text.split('\n')[:-2])
            await utils.answer(message, response.text)

            


    @loader.command(alias = 'eh')
    async def evoh(self, message: Message):
        """[ ĞĞ¸Ñ‡ĞµĞ³Ğ¾/ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ¿Ğ¸ĞºĞ° ] - Ğ’Ñ‹Ğ²ĞµÑÑ‚Ğ¸ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ Ğ¿Ğ¾ Ğ²ÑĞµĞ¼ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°Ğ¼, ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ¸Ğ²Ğ°ÑÑ‚ÑÑ Ğ¼Ğ¾Ğ´ÑƒĞ»ĞµĞ¼"""
        args = utils.get_args_raw(message)

        #Topics
        topic_full = "<b><emoji document_id=5334882760735598374>ğŸ“</emoji> ĞŸĞ¾Ğ¼Ğ¾Ñ‰ÑŒ Ğ¿Ğ¾ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ°Ğ¼</b>\n\n"
        topic_boost = "<b>> <emoji document_id=5445284980978621387>ğŸš€</emoji> Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹</b>\n"
        topic_cases = "<b>> <emoji document_id=5359785904535774578>ğŸ’¼</emoji> ĞšĞµĞ¹ÑÑ‹</b>\n"
        topic_top = "<b>> <emoji document_id=5188208446461188962>ğŸ’¯</emoji> Ğ¢Ğ¾Ğ¿</b>\n"
        topic_stats = "<b>> <emoji document_id=5373001317042101552>ğŸ“ˆ</emoji> Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°</b>\n"
        topic_other = "<b>> <emoji document_id=5370869711888194012>ğŸ‘¾</emoji> ĞŸÑ€Ğ¾Ñ‡ĞµĞµ</b>\n"
        topic_storage = "<b>> <emoji document_id=5431736674147114227>ğŸ—‚</emoji> Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ</b>\n"
        topic_add = "Ğ§Ñ‚Ğ¾Ğ±Ñ‹ Ğ¿Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ¾Ñ‚Ğ´ĞµĞ»ÑŒĞ½Ñ‹Ğ¹ Ñ‚Ğ¾Ğ¿Ğ¸Ğº, Ğ½Ğµ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾ Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ ĞµĞ³Ğ¾ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ, Ğ´Ğ¾ÑÑ‚Ğ°Ñ‚Ğ¾Ñ‡Ğ½Ğ¾ Ğ½Ğ°Ğ¿Ğ¸ÑĞ°Ñ‚ÑŒ Ğ»ÑĞ±ÑƒÑ ĞºĞ¾Ğ¼Ğ°Ğ½Ğ´Ñƒ Ğ¸Ğ· ÑÑ‚Ğ¾Ğ³Ğ¾ Ñ‚Ğ¾Ğ¿Ğ¸ĞºĞ°"
        
        #Commands
        cmdboost = "  > Ğ‘ÑƒÑÑ‚ [ Ğ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ° ] [ ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ ]\n    > Ñ€ | Ğ´ | Ğ³Ñ€ | Ğ³Ğ´\n    > 1.5 | 2 | 2.5 | 3\n  > Ğ‘ÑƒÑÑ‚Ñ‹\n  > ĞšÑ€Ğ°Ñ„Ñ‚ [ Ğ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ° ] [ ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ ]\n    > Ñ€ | Ğ´\n    > 2 | 2.5 | 3\n  > Ğ£Ñ‚Ğ¸Ğ»ÑŒ [ Ğ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ° ] [ ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ ]\n    > Ñ€ | Ğ´\n    > 1.5 | 2 | 2.5 | 3\n  > Ğ’Ñ€ĞµĞ¼Ñ\n\n"
        cmdcases = "  > ĞšĞµĞ¹ÑÑ‹\n  > ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ [ Ğ¢Ğ¸Ğ¿ ĞºĞµĞ¹ÑĞ° ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾ ]\n    > ĞšÑ‚ | Ğ ĞºÑ‚ | Ğš | Ğ Ğº | ĞœĞ¸Ñ„ | ĞšÑ€ | Ğ—Ğ² \n  > Ğ”Ğ°Ñ‚ÑŒ [ Ğ¢Ğ¸Ğ¿ ĞºĞµĞ¹ÑĞ° ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾ ]\n    > ĞšÑ‚ | Ğ ĞºÑ‚ | Ğš | Ğ Ğº | ĞœĞ¸Ñ„ | ĞšÑ€ | Ğ—Ğ²\n  > ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ [ Ğ¢Ğ¸Ğ¿ ĞºĞµĞ¹ÑĞ° ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾ ]\n    > ĞšÑ‚ | Ğ ĞºÑ‚ | Ğš | Ğ Ğº | ĞœĞ¸Ñ„ | ĞšÑ€ | Ğ—Ğ² \n\n"
        cmdtop = "  > Ğ¢Ğ¾Ğ¿\n  > Ğ¢Ğ¾Ğ¿ [ Ğ¢Ğ¸Ğ¿ Ñ‚Ğ¾Ğ¿Ğ° ]\n    >  Ğº | Ğ´ | Ğ± | Ñ€ | ĞºĞ»Ğ°Ğ½\n\n"
        cmdstats = "  > ĞŸÑ€Ğ¾Ñ„ \n  > Ğ¡Ñ‚Ğ°Ñ‚Ğ° \n  > Ğ›Ğ¸Ğ¼\n  > ĞœĞ¾Ğ¹ Ñ€ĞµÑ„\n\n"
        cmdstorage = "  > Ğ‘\n  > ĞŸ\n  > C\n  > Ğ—Ğ¿\n  > Ğ˜Ğ½Ğ²\n  > ĞŸÑ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ [ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ€ÑƒĞ´Ñ‹ ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾/Ğ’ÑĞµ ]\n  > ĞŸĞµÑ€ĞµĞ²ĞµÑÑ‚Ğ¸ [ ĞĞ¸Ğº ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾ Ğ´ĞµĞ½ĞµĞ³/Ğ›Ğ¸Ğ¼Ğ¸Ñ‚ ]\n\n"
        cmdother = "  > Ğ ĞµÑ„ [ Ğ ĞµÑ„ĞµÑ€Ğ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºĞ¾Ğ´ ]\n  > Ğ˜Ğ²ĞµĞ½Ñ‚\n  > ĞšĞ¾Ğ½ĞºÑƒÑ€Ñ\n  > Ğ•Ğ±\n  > Thx\n  > Ğ¦ĞµĞ½Ñ‹\n  > Ğ Ñ‹Ğ½Ğ¾Ğº\n\n"
        
        #Error
        err_topic = "<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ°</b>\nĞ¢Ğ¾Ğ¿Ğ¸Ğº Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.\nĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ¿Ğ¸ĞºĞ¾Ğ² Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ğ¾ÑĞ¼Ğ¾Ñ‚Ñ€ĞµÑ‚ÑŒ Ğ² evoh."
        
        if args in ['Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹','Ğ±ÑƒÑÑ‚ĞµÑ€Ñ‹','Ğ‘ÑƒÑÑ‚Ñ‹','Ğ±ÑƒÑÑ‚Ñ‹','Ğ‘ÑƒÑÑ‚','Ğ±ÑƒÑÑ‚','ĞšÑ€Ğ°Ñ„Ñ‚','ĞºÑ€Ğ°Ñ„Ñ‚','Ğ£Ñ‚Ğ¸Ğ»ÑŒ','ÑƒÑ‚Ğ¸Ğ»ÑŒ','Ğ’Ñ€ĞµĞ¼Ñ','Ğ²Ñ€ĞµĞ¼Ñ']:
            await utils.answer(message, topic_full + topic_boost + cmdboost)
        
        elif args in ['ĞšĞµĞ¹ÑÑ‹','ĞºĞµĞ¹ÑÑ‹','ĞÑ‚ĞºÑ€Ñ‹Ñ‚ÑŒ','Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚ÑŒ','Ğ”Ğ°Ñ‚ÑŒ','Ğ´Ğ°Ñ‚ÑŒ','ĞŸĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ','Ğ¿ĞµÑ€ĞµĞ´Ğ°Ñ‚ÑŒ']:
            await utils.answer(message, topic_full + topic_cases + cmdcases)
        
        elif args in ['Ğ¢Ğ¾Ğ¿','Ñ‚Ğ¾Ğ¿']:
            await utils.answer(message, topic_full + topic_top + cmdtop)
        
        elif args in ['Ğ¡Ñ‚Ğ°Ñ‚','ÑÑ‚Ğ°Ñ‚','Ğ¡Ñ‚Ğ°Ñ‚Ğ°','ÑÑ‚Ğ°Ñ‚Ğ°','Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°','ÑÑ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°','ĞŸÑ€Ğ¾Ñ„','Ğ¿Ñ€Ğ¾Ñ„','Ğ›Ğ¸Ğ¼','Ğ»Ğ¸Ğ¼','Ğ›Ğ¸Ğ¼Ğ¸Ñ‚','Ğ»Ğ¸Ğ¼Ğ¸Ñ‚','ĞœĞ¾Ğ¹ Ñ€ĞµÑ„','Ğ¼Ğ¾Ğ¹ Ñ€ĞµÑ„']:
            await utils.answer(message, topic_full + topic_stats + cmdstats)
        
        elif args in ['Ğ¥Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ','Ñ…Ñ€Ğ°Ğ½Ğ¸Ğ»Ğ¸Ñ‰Ğµ','Ğ‘','Ğ±','ĞŸ','Ğ¿','Ğ¡','Ñ','Ğ—Ğ¿','Ğ·Ğ¿','Ğ˜Ğ½Ğ²','Ğ¸Ğ½Ğ²','ĞŸÑ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ','Ğ¿Ñ€Ğ¾Ğ´Ğ°Ñ‚ÑŒ','ĞŸĞµÑ€ĞµĞ²ĞµÑÑ‚Ğ¸','Ğ¿ĞµÑ€ĞµĞ²ĞµÑÑ‚Ğ¸']:
            await utils.answer(message, topic_full + topic_storage + cmdstorage )
        
        elif args in ['ĞŸÑ€Ğ¾Ñ‡ĞµĞµ','Ğ¿Ñ€Ğ¾Ñ‡ĞµĞµ','Ğ ĞµÑ„','Ñ€ĞµÑ„','Ğ˜Ğ²ĞµĞ½Ñ‚','Ğ¸Ğ²ĞµĞ½Ñ‚','ĞšĞ¾Ğ½ĞºÑƒÑ€Ñ','ĞºĞ¾Ğ½ĞºÑƒÑ€Ñ','Ğ•Ğ±','ĞµĞ±','Thx','thx','Ğ¦ĞµĞ½Ñ‹','Ñ†ĞµĞ½Ñ‹','Ğ Ñ‹Ğ½Ğ¾Ğº','Ñ€Ñ‹Ğ½Ğ¾Ğº']:
            await utils.answer(message, topic_full + topic_other + cmdother)
        
        elif args == '':
            await utils.answer(message, topic_full + topic_boost + cmdboost + topic_cases + cmdcases + topic_top + cmdtop + topic_stats + cmdstats + topic_storage + cmdstorage + topic_other + cmdother + topic_add)
        
        else:
            await utils.answer(message, err_topic)

    @loader.command(alias = 'c')
    async def craft(self, message: Message):
        """[ Ğ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ° ( Ñ€ / Ğ´ ) ] [ ĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ ] [ ĞšĞ¾Ğ»-Ğ²Ğ¾ ] - Ğ°Ğ²Ñ‚Ğ¾Ğ¼Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ĞºÑ€Ğ°Ñ„Ñ‚ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ¾Ğ²"""
        await utils.answer(message, '<b>[ Craft ]</b> ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ ĞºÑ€Ğ°Ñ„Ñ‚ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ¾Ğ²...\n\nĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…... [ args, delay, type, mult, quantity, quantityl, errtype, errmult, startcraft ]')
        args = utils.get_args_split_by(message, " ")
        delay = self.config["delay_craft"]
        type = args[0]
        mult = args[1]
        quantity = args[2]
        quantityl = quantity
        errtype = f'<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ° </b>\nĞ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ° "{type}" Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.\nĞœĞ¾Ğ¶Ğ½Ğ¾ ĞºÑ€Ğ°Ñ„ÑÑ‚Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ±ÑƒÑÑ‚ĞµÑ€Ñ‹:\nĞ , Ñ€ - Ñ€ÑƒĞ´Ğ°\nĞ”, Ğ´ - Ğ´ĞµĞ½ÑŒĞ³Ğ¸'
        errmult = f'<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ° </b>\nĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»Ñ "{mult}" Ğ½Ğµ ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚.\nĞ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞ¹Ñ‚Ğµ: 2, 2.0, 2.5, 3, 3.0'
        startcraft = 0
        await utils.answer(message, '<b>[ Craft ]</b> ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ ĞºÑ€Ğ°Ñ„Ñ‚ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ¾Ğ²...\n\nĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…... [ args, delay, type, mult, quantity, quantityl, errtype, errmult, startcraft ] \n\nĞšÑ€Ğ°Ñ„Ñ‚Ğ¸Ğ¼...')
        if type in ['Ğ ', 'Ñ€', 'Ğ”', 'Ğ´' ]:
            if mult in ['2', '2.0', '2.5', '3', '3.0']:
                while int(quantity) > 0:
                    quantity = int(quantity) - 1
                    async with self.client.conversation(self._backup_channel) as conv:   
                        await conv.send_message(f'ĞšÑ€Ğ°Ñ„Ñ‚ {type} {mult}')
                        await asyncio.sleep(delay)
                        startcraft = startcraft + 1
                        await utils.answer(message, f'<b>[ Craft ]</b> ĞĞ°Ñ‡Ğ¸Ğ½Ğ°Ñ ĞºÑ€Ğ°Ñ„Ñ‚ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ¾Ğ²...\n\nĞŸĞ¾Ğ´Ğ³Ğ¾Ñ‚Ğ¾Ğ²ĞºĞ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…... [ args, delay, type, mult, quantity, quantityl, errtype, errmult, startcraft ] \n\nĞšÑ€Ğ°Ñ„Ñ‚Ğ¸Ğ¼...\n\nĞÑ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ² Ğ½Ğ° Ğ´Ğ°Ğ½Ğ½Ñ‹Ğ¹ Ğ¼Ğ¾Ğ¼ĞµĞ½Ñ‚: {startcraft}')
                await asyncio.sleep(2)    
                async with self.client.conversation(self._backup_channel) as conv:   
                        await conv.send_message(f'Ğ‘ÑƒÑÑ‚Ñ‹')
                        response = (await conv.get_response()).message
                        response = response[:-2]
                await utils.answer(message, '<b>[ Craft ]</b> ĞšÑ€Ğ°Ñ„Ñ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!\n\n\n<code>Ğ—Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ° Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ğ¸...</code>')
                await asyncio.sleep(1)
                if type == 'Ğ´':
                    type = 'Ğ”ĞµĞ½ÑŒĞ³Ğ¸'
                elif type == 'Ñ€':
                    type = 'Ğ ÑƒĞ´Ğ°'
                await utils.answer(message, f"<b>[ Craft ]</b> ĞšÑ€Ğ°Ñ„Ñ‚ Ğ·Ğ°Ğ²ĞµÑ€ÑˆĞµĞ½!\n\n<b>Ğ˜Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ:</b>\nĞ¢Ğ¸Ğ¿ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ°: {type}\nĞœĞ½Ğ¾Ğ¶Ğ¸Ñ‚ĞµĞ»ÑŒ Ğ±ÑƒÑÑ‚ĞµÑ€Ğ°: {mult}\nĞšĞ¾Ğ»-Ğ²Ğ¾ Ñ€Ğ°Ğ· Ğ¾Ñ‚Ğ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¾: {quantityl}\nĞ‘Ñ‹Ğ»Ğ° Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºĞ°: {delay}\n\n<b>Ğ˜Ñ‚Ğ¾Ğ³Ğ¾Ğ²Ñ‹Ğ¹ ÑĞ¿Ğ¸ÑĞ¾Ğº Ğ±ÑƒÑÑ‚ĞµÑ€Ğ¾Ğ²:</b>\n{response}")
            else:
                await utils.answer(message, errmult)
        else:
            await utils.answer(message, errtype)

    @loader.command(alias = 't')    
    async def top(self, message):
        ''' - Ğ¸Ğ½Ğ»Ğ°Ğ¹Ğ½ Ñ‚Ğ¾Ğ¿'''
        gif_on_top = self.config['gif_inline']

        await self.inline.form(
            text = 'Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¾Ğ¿: ',
            gif = gif_on_top,
            message=message,
            reply_markup=[
                [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback':self.topbalance,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],              
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )
    @loader.command(alias = 'p')    
    async def prof(self, message):
        ''' - Ğ¸Ğ½Ğ»Ğ°Ğ¹Ğ½ Ğ¿Ñ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ'''
        gif_on_top = self.config['gif_inline']

        await self.inline.form(
            text = 'ĞšÑƒĞ´Ğ° Ğ¿Ğ¾Ğ¹Ğ´ĞµĞ¼?',
            gif = gif_on_top,
            message=message,
            reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],      
                    [
                        {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                        },
                    ],
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
            ],
        )


    @loader.command(alias = 'aa')
    async def autoattack(self, message):
        ''' - Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ\Ğ²Ñ‹ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ°Ñ‚Ğ°ĞºĞµÑ€'''
        self.config['autoattack'] = not self.config['autoattack']
        cfg = self.config['autoattack']
        if cfg == True:
            await utils.answer(message, '<b>[ AutoAttack ] </b>ĞĞ²Ñ‚Ğ¾ĞÑ‚Ğ°ĞºĞµÑ€ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½.')
        if cfg == False:
            await utils.answer(message, '<b>[ AutoAttack ] </b>ĞĞ²Ñ‚Ğ¾ĞÑ‚Ğ°ĞºĞµÑ€ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½.')

    @loader.command(alias = 'pt')
    async def petroleum(self, message):
        ''' - Ğ²ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ/Ğ²Ñ‹ĞºĞ»ÑÑ‡Ğ¸Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ñƒ Ğ½ĞµÑ„Ñ‚Ğ¸'''
        self.config['petroleum'] = not self.config['petroleum']
        cfg = self.config['petroleum']
        if cfg == True:
            await utils.answer(message, '<b>[ Petroleum ]</b> ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ğ° Ğ½ĞµÑ„Ñ‚Ğ¸ Ğ²ĞºĞ»ÑÑ‡ĞµĞ½Ğ°.')
            await self.client.send_message('@mine_evo_bot', 'ĞšĞ°Ñ‡Ğ°Ñ‚ÑŒ')
        if cfg == False:
            await utils.answer(message, '<b>[ Petroleum ]</b> ĞĞ²Ñ‚Ğ¾Ğ´Ğ¾Ğ±Ñ‹Ñ‡Ğ° Ğ½ĞµÑ„Ñ‚Ğ¸ Ğ¾Ñ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ°.')

    @loader.command()
    async def scfg(self, message):
        '''[ delay_craft / delay_boss / gif_inline / waiting_time ] [ Ğ—Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ]- Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ¿Ğ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ Ğ±ĞµĞ· Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ğ¸Ñ ĞºĞ¾Ğ½Ñ„Ğ¸Ğ³Ğ°\ndelay_craft - Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ğ´Ğ»Ñ ĞºÑ€Ğ°Ñ„Ñ‚Ğ°\ndelay_boss - Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ·Ğ°Ğ´ĞµÑ€Ğ¶ĞºÑƒ Ğ°Ñ‚Ğ°ĞºĞ¸ Ğ±Ğ¾ÑÑĞ°\ngif_inline - Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ñ‚ÑŒ Ğ³Ğ¸Ñ„ Ğ² Ğ¸Ğ½Ğ»Ğ°Ğ¹Ğ½ Ñ„ÑƒĞ½ĞºÑ†Ğ¸ÑÑ…\nwaiting_time - Ğ²Ñ€ĞµĞ¼Ñ Ğ¾Ğ¶Ğ¸Ğ´Ğ°Ğ½Ğ¸Ñ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ° Ğ¾Ñ‚ Ğ±Ğ¾Ñ‚Ğ° Ğ´Ğ»Ñ evo'''
        args = utils.get_args_raw(message).split(" ")
        param = args[0]
        zz = args[1]

        if param == 'delay_boss':
            self.config['delay_boss'] = zz
            await utils.answer(message, f'<b>[ Config ] </b>ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ <code>{param}</code> Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° <code>{zz}</code>')
            return
        if param == 'delay_craft':
            self.config['delay_craft'] = zz
            await utils.answer(message, f'<b>[ Config ] </b>ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ <code>{param}</code> Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° <code>{zz}</code>')
            return
        if param == 'gif_inline':
            self.config['gif_inline'] = zz
            await utils.answer(message, f'<b>[ Config ] </b>ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ <code>{param}</code> Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° <code>{zz}</code>')
            return
        if param == 'waiting_time':
            self.config['waiting_time'] = zz
            await utils.answer(message, f'<b>[ Config ] </b>ĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ <code>{param}</code> Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½ Ğ½Ğ° <code>{zz}</code>')
            return
        else:
            await utils.answer(message, f'<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ°</b>\nĞŸĞ°Ñ€Ğ°Ğ¼ĞµÑ‚Ñ€ <code>{param}</code> Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½.')


    @loader.command()
    async def upd(self, message):
        '''[ ĞĞ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ ( Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ¨Ğ¿ ) ] - ÑƒĞ»ÑƒÑ‡ÑˆĞ¸Ñ‚ÑŒ Ñ‡Ñ‚Ğ¾-Ğ»Ğ¸Ğ±Ğ¾'''
        args = utils.get_args_raw(message)
        if args in ['Ğ£Ñ€','ÑƒÑ€','ĞœÑ‰','Ğ¼Ñ‰','Ğ£Ğ´','ÑƒĞ´','Ğ£Ñ€Ğ¾Ğ½','ÑƒÑ€Ğ¾Ğ½','ĞšÑ€Ğ¸Ñ‚','ĞºÑ€Ğ¸Ñ‚','Ğ¨Ğ¿','ÑˆĞ¿','Ğ£Ğ¿','ÑƒĞ¿','Ğ¨Ğº','ÑˆĞº','ĞœÑ€','Ğ¼Ñ€','ĞœĞ¿','Ğ¼Ğ¿','ĞœÑ','Ğ¼Ñ','ĞœÑƒ','Ğ¼Ñƒ']:
            await utils.answer(message, '<b>[ upd ]</b> Ğ’Ñ‹Ğ¿Ğ¾Ğ»Ğ½ÑĞµÑ‚ÑÑ...')
            async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'{args}')
                res = await conv.get_response()
                await res.click(0)
            await utils.answer(message, f'Ğ’Ğ¾Ñ‚, Ñ‡Ñ‚Ğ¾ Ğ½ÑƒĞ¶Ğ½Ğ¾ Ğ±Ñ‹Ğ»Ğ¾ Ğ´Ğ»Ñ ÑƒĞ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ñ:\n\n{res}')
            return
        else:
            await utils.answer(message, f'<emoji document_id=5877477244938489129>ğŸš«</emoji> <b>Error | ĞÑˆĞ¸Ğ±ĞºĞ°</b>\nĞ£Ğ»ÑƒÑ‡ÑˆĞµĞ½Ğ¸Ğµ <code>{args}<code> Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾.')

    async def toplvl(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
                [
                    {
                        "text": "> â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ <",
                        "callback": None,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback': self.topbalance,
                    }
                ],         
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )
        
    async def topclicks(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿ Ğº')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
               [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "> ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ <",
                        "callback": None,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback':self.topbalance,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],      
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
                
            ],
        )
    async def topdonate(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿ Ğ´')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
                [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "> ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚ <",
                        "callback": None,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback':self.topbalance,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],            
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )

    async def topore(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿ Ñ€')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
                [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "> ğŸ§± Ğ ÑƒĞ´Ğ° <",
                        "callback": None,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback':self.topbalance,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],             
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )

    async def topclan(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿ ĞºĞ»Ğ°Ğ½')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
                [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "> ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹ <",
                        "callback": None,
                    },
                    {
                        'text':'ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ',
                        'callback':self.topbalance,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],               
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )    

    async def topbalance(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
                await conv.send_message(f'Ñ‚Ğ¾Ğ¿ Ğ±')
                response = (await conv.get_response()).message
        await call.edit(
            text=response,
            reply_markup=[
                [
                    {
                        "text": "â­ï¸ Ğ£Ñ€Ğ¾Ğ²ĞµĞ½ÑŒ",
                        "callback": self.toplvl,
                    },
                    {
                        "text": "ğŸ‘† ĞšĞ»Ğ¸ĞºĞ¸ ",
                        "callback": self.topclicks,
                    },
                ],
                [
                    
                    {
                        "text": "ğŸ’ Ğ”Ğ¾Ğ½Ğ°Ñ‚",
                        "callback": self.topdonate,
                    },
                    {
                        "text": "ğŸ§± Ğ ÑƒĞ´Ğ°",
                        "callback": self.topore,
                    }
                ],
                [
                    {
                        "text": "ğŸ° ĞšĞ»Ğ°Ğ½Ñ‹",
                        "callback": self.topclan,
                    },
                    {
                        'text':'> ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ <',
                        'callback': None,
                    }
                ],
                [
                    {
                        'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                        'callback': self.donate_author,
                    },
                ],              
                [
                    {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                    }
                ],
            ],
        )


    

    async def stor_prof(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ¿Ñ€Ğ¾Ñ„')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "> ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ  <",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],     
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )    

    async def stor_stata(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('ÑÑ‚Ğ°Ñ‚Ğ°')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': '> ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ° <',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],      
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )            

    async def stor_inv(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ¸Ğ½Ğ²')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "> ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ <",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],      
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )            

    async def stor_cases(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('ĞºĞµĞ¹ÑÑ‹')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'> ğŸ“¦ ĞšĞµĞ¹ÑÑ‹ <',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],   
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )     

    async def stor_boosters(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ±ÑƒÑÑ‚Ñ‹')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'> âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹ <',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],      
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )                   

    async def stor_plasm(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ¿')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "> ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ° <",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],  
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )          

    async def stor_balance(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ±')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "> ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ <",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],   
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )              

    async def stor_scrap(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ñ')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': 'ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "> ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿ <",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],   
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )            

    async def stor_star(self, call: InlineCall):
        async with self.client.conversation(self._backup_channel) as conv:
            await conv.send_message('Ğ·Ğ¿')
            response = (await conv.get_response()).message
            links_regex = re.compile(r'.(https?://\S+).')
            response = links_regex.sub('', response)
            if re.findall('http[s]?://(?:[a-zA-Z]|[0-9]|[$-@.&+]|[!*(),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+', response):
                response = '\n'.join(response.split('\n')[:-2])
            await call.edit(
                text=response,
                reply_markup=[
                    [
                        {
                            "text": "ğŸ“‹ ĞŸÑ€Ğ¾Ñ„Ğ¸Ğ»ÑŒ",
                            "callback": self.stor_prof,
                        },
                        {
                            'text': 'ğŸ“ˆ Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°',
                            'callback': self.stor_stata,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ’ Ğ˜Ğ½Ğ²ĞµĞ½Ñ‚Ğ°Ñ€ÑŒ",
                            "callback": self.stor_inv,
                        },
                    ],
                    [
                        {
                            'text': '> ğŸŒŒ Ğ—Ğ²ĞµĞ·Ğ´Ğ½Ğ°Ñ ĞŸÑ‹Ğ»ÑŒ <',
                            'callback': self.stor_star
                        }
                    ],
                    [
                        {
                            'text':'ğŸ“¦ ĞšĞµĞ¹ÑÑ‹',
                            'callback':self.stor_cases,
                        },
                        {
                            'text':'âš¡ï¸ Ğ‘ÑƒÑÑ‚ĞµÑ€Ñ‹',
                            'callback':self.stor_boosters,
                        }
                    ],
                    [
                        {
                            "text": "ğŸ† ĞŸĞ»Ğ°Ğ·Ğ¼Ğ°",
                            "callback": self.stor_plasm,
                        },
                        {
                            "text": "ğŸ’µ Ğ‘Ğ°Ğ»Ğ°Ğ½Ñ",
                            "callback": self.stor_balance,
                        },
                        {
                            "text": "ğŸ”© Ğ¡ĞºÑ€Ğ°Ğ¿",
                            "callback": self.stor_scrap,
                        }
                    ],
                    [
                        {
                            'text':'ğŸ’° ĞŸĞ¾Ğ´Ğ´ĞµÑ€Ğ¶Ğ°Ñ‚ÑŒ Ğ°Ğ²Ñ‚Ğ¾Ñ€Ğ° ( 1 ĞºĞµĞ¹Ñ )',
                            'callback': self.donate_author,
                        },
                    ],      
                    [
                        {
                        "text": "ğŸ”» Ğ—Ğ°ĞºÑ€Ñ‹Ñ‚ÑŒ",
                        "action": "close",
                        }
                    ],
                ],
            )            

    async def donate_author(self, call: InlineCall):
        await self.client.send_message('@mine_evo_bot','Ğ”Ğ°Ñ‚ÑŒ # Ğº 1')
        await call.answer('Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾ â¤ï¸')